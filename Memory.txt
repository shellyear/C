1Ô∏è‚É£.  memory layout of process

## General Multi-Threaded Process Memory Layout
- Each process has a virtual memory space divided into different segments. Some of these segments are shared among all threads, while others (like the stack) are unique to each thread.

High Memory (Largest Addresses)
---------------------------------------------------
|  Command-line Arguments & Environment Variables  | Read-Only  (r--); Shared by all threads
---------------------------------------------------
|  Thread 1 Stack (Grows Down)                     | Read-Write (rw-)
|  Thread 2 Stack (Grows Down)                     | Read-Write (rw-)
|  Thread 3 Stack (Grows Down)                     | Read-Write (rw-)
|  ...                                             | Private to each thread
---------------------------------------------------
|  Heap (Grows Up)                                 | Read-Write (rw-)
|  Used for dynamically allocated memory (malloc)  | Shared by all threads
---------------------------------------------------
|  BSS (Uninitialized Global/Static Variables)     | Read-Write (rw-) 
|  Stores uninitialized global/static variables    | Shared by all threads                
---------------------------------------------------
|  Data (Initialized Global/Static Variables)      | Read-Write (rw-)
|  Stores initialized global/static variables      | Shared by all threads
---------------------------------------------------
|  Text (Code Segment - Executable Instructions)   | Read-Execute (r-x)
|  Stores machine code (compiled program)          | Shared by all threads
---------------------------------------------------
Low Memory (Smallest Addresses)

2Ô∏è‚É£. How much memory each segment of memory layout takes

## General Multi-Threaded Process Memory Layout
High Memory (Largest Addresses)
--------------------------------------------------------------------------------
|  Command-line Arguments & Environment Variables  | ~128KB - 2MB   | Read-Only  (r--) |
--------------------------------------------------------------------------------
|  Thread 1 Stack (Grows Down)                     | ~8MB (Default) | Read-Write (rw-) |
|  Thread 2 Stack (Grows Down)                     | ~8MB (Default) | Read-Write (rw-) |
|  Thread 3 Stack (Grows Down)                     | ~8MB (Default) | Read-Write (rw-) |
|  ...                                             |                |                 |
--------------------------------------------------------------------------------
|  Heap (Grows Up)                                 | Dynamic        | Read-Write (rw-) |
|  Used for dynamically allocated memory (malloc)  |                |                 |
--------------------------------------------------------------------------------
|  BSS (Uninitialized Global/Static Variables)     | ~8KB - 1MB     | Read-Write (rw-) |
|  Stores uninitialized global/static variables    |                |                 |
--------------------------------------------------------------------------------
|  Data (Initialized Global/Static Variables)      | ~8KB - 1MB     | Read-Write (rw-) |
|  Stores initialized global/static variables      |                |                 |
--------------------------------------------------------------------------------
|  Text (Code Segment - Executable Instructions)   | ~1MB - 10MB    | Read-Execute (r-x) |
|  Stores machine code (compiled program)          |                |                 |
--------------------------------------------------------------------------------
Low Memory (Smallest Addresses)

3Ô∏è‚É£. Heap (Grows up) theoretically can collide with stacks(Grows down in memory)

   - Modern OS's implement protections to prevent this from happening:
   1. The OS ensures there‚Äôs enough gap between the heap and stacks to prevent overlap
      - If the heap gets too large, the OS moves it using mmap() instead of sbrk().
   2. The OS places a guard page (a small protected memory region) below each stack.
      - If a stack overflows into this guard page ‚Üí segmentation fault happens before the heap is reached.
   3. üîπ Heap Allocations Use mmap() When Large
      - If malloc() requests a very large chunk of memory (e.g., >128KB), it doesn‚Äôt use the normal heap.
      - Instead, it allocates memory using mmap(), which places the memory elsewhere, avoiding stack collisions.

    üîπ What Happens If a Collision Occurs?
    1. Segmentation Fault (SIGSEGV)
       - If the stack overflows into protected memory, the OS terminates the process.
    2. Silent Memory Corruption (Rare, but Dangerous)
       - If protections are disabled (e.g., custom memory management), the heap might overwrite the stack or vice versa, causing random crashes.
    3. Heap Allocation Failure
       - If the heap tries to expand but there‚Äôs no space, malloc() returns NULL, and your program should handle this.

4Ô∏è‚É£. C compiling stages:
   - Compiling C code happens in four main stages, often abbreviated as PPLC:
     1Ô∏è‚É£ Preprocessing (cpp)
        - Expands macros, includes headers, and processes # directives, removes comments
        - gcc -E program.c -o program.i
     2Ô∏è‚É£ Compilation (cc1)
        - Checks for syntax errors
        - Optimizes the code.
        - Translates high-level C code into assembly instructions.
        - gcc -S program.i -o program.s
     3Ô∏è‚É£ Assembly (as)
        - Translates Assembly instructions into CPU instructions (binary).
        - Assigns labels (symbols/symbolic addresses) to variables and functions for variables & functions within the object file (.o)
          These symbols are not yet assigned final memory addresses ‚Äî instead, they are given relative locations within sections (like .text, .data, .bss, .rodata)
          The assembler generates a relocatable object file (.o), where function and variable addresses are still placeholders.
        - Creates an object file (.o)
        - gcc -c program.s -o program.o
     4Ô∏è‚É£ Linking (ld)
        - Resolves function calls (e.g., printf() ‚Üí libc)
        - Links multiple object files (.o) together
        - Replaces symbols with actual memory addresses (it decides them based on predefined rules, system constraints, and the memory layout of the program)
        - Adds standard library code (like stdio.h)
        - Produces the final executable file

   This runs all four stages automatically: gcc program.c -o program


