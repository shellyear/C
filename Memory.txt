1ï¸âƒ£.  Memory layout of process (process structure in a UNIX-based OS environment)

## General Multi-Threaded Process Memory Layout
- Each process has a virtual memory space divided into different segments. Some of these segments are shared among all threads, while others (like the stack) are unique to each thread.

HIGH MEMORY (Largest Addresses) (e.g., 0xFFFFFFFF)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|  KERNEL SPACE (NOT directly Accessible to Process)   |  <-- Managed by OS - shared by all processes. (KERNEL SPACE is not part of the process, it belongs to the OS)
|  - System calls, device drivers, memory management   |   When a process needs to interact with the kernel (e.g., file I/O, networking, memory management), it must use system calls (like read(), write(), mmap())
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|  COMMAND-LINE ARGUMENTS & ENV VARIABLES              |  ~128KB - 2MB  
|  - Passed to `main()` on program start               |  Read-Only (r--)  
|  - Shared by all threads                             |
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|  THREAD 1 STACK (Grows Down)                         |  ~8MB (Default)
|  - Function calls, return addresses, local vars      |  Read-Write (rw-)  
|  - Private to Thread 1                               |
|------------------------------------------------------|
|  THREAD 1 GUARD PAGE (Protects Stack)                |  ~4KB - 64KB  (---)
|------------------------------------------------------|
|  THREAD 1 LOCAL STORAGE (TLS)                        |  ~8KB - 64KB  
|  - Stores thread-specific `thread_local` variables   |  Read-Write (rw-)  
|  - Private to Thread 1                               |  
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|  MAIN THREAD STACK (Grows Down)                      |  ~8MB (Default)
|  - Function calls, return addresses, local vars      |  Read-Write (rw-)  
|  - Private to Main Thread                            |
|------------------------------------------------------|
|  MAIN THREAD GUARD PAGE (Protects Stack)             |  ~4KB - 64KB  (---)  
|------------------------------------------------------|
|  MAIN THREAD LOCAL STORAGE (TLS)                     |  ~8KB - 64KB  
|  - Stores thread-specific `thread_local` variables   |  Read-Write (rw-)  
|  - Private to Main Thread                            |
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|  HEAP (Grows Up)                                     |  Dynamic
|  - Stores dynamically allocated memory (`malloc`)    |  Read-Write (rw-)  
|  - Shared by both threads                            |  BSS - Block Started by Symbol
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|  BSS (Uninitialized Global/Static Variables)         |  ~8KB - 1MB
|  - Global/static variables with no explicit value    |  Read-Write (rw-)
|  - Shared by both threads                            |
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|  DATA (Initialized Global/Static Variables)          |  ~8KB - 1MB  
|  - Global/static variables with initial values       |  Read-Write (rw-)  
|  - Shared by both threads                            |
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|  READ-ONLY DATA (.rodata)                            |  ~4KB - 1MB  
|  - Stores constants, string literals, `const` vars   |  Read-Only (r--)  
|  - Shared by both threads                            |
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
|  TEXT (CODE SEGMENT)                                 |  ~1MB - 10MB  
|  - Stores executable machine code                    |  Read-Execute (r-x)  
|  - Shared by both threads                            |
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LOW MEMORY (Smallest Addresses) (e.g., 0x00000000)

2ï¸âƒ£. Heap (Grows up) theoretically can collide with stacks(Grows down in memory)

   - Modern OS's implement protections to prevent this from happening:
   1. The OS ensures thereâ€™s enough gap between the heap and stacks to prevent overlap
      - If the heap gets too large, the OS moves it using mmap() instead of sbrk().
   2. The OS places a guard page (a small protected memory region) below each stack.
      - If a stack overflows into this guard page â†’ segmentation fault happens before the heap is reached.
   3. ğŸ”¹ Heap Allocations Use mmap() When Large
      - If malloc() requests a very large chunk of memory (e.g., >128KB), it doesnâ€™t use the normal heap.
      - Instead, it allocates memory using mmap(), which places the memory elsewhere, avoiding stack collisions.

    ğŸ”¹ What Happens If a Collision Occurs?
    1. Segmentation Fault (SIGSEGV)
       - If the stack overflows into protected memory, the OS terminates the process.
    2. Silent Memory Corruption (Rare, but Dangerous)
       - If protections are disabled (e.g., custom memory management), the heap might overwrite the stack or vice versa, causing random crashes.
    3. Heap Allocation Failure
       - If the heap tries to expand but thereâ€™s no space, malloc() returns NULL, and your program should handle this.


3ï¸âƒ£. How CPU accesses memory address in RAM without RAM looping through all memory addresses ? (With and without virtual memory)
4ï¸âƒ£. Memory layout of RAM
5ï¸âƒ£. What is Virtual Memory ? And what does it solve ? (Memory not enough, memory fragmentation, security)
6ï¸âƒ£. 2 to the power of 32 addresses for each byte corresponds to the 2 to the power of 30 words in 32bit cpu ? Why 2 is used in the power of 32 ? 

7ï¸âƒ£. Types of Memory: 
  1. Primary Memory (Volatile Memory) - RAM, CPU Cache(L1, L2, L3), CPU register memory
  2. Secondary Memory (Non-volatile Memory) - HDD, SSD, NVMe, Flash memory(USB, SD cards, EEPROM)
  3. Tertiary Storage (Backup & Archival Memory) - Magnetic Tape, Optical Discs (CD/DVD/Blu-ray)
  4. Virtual Memory (Abstracted Memory Management)
     - Paging Memory
     - Segmented Memory
     - Segmented Paging Memory
     - Swap Memory (Swap Space, Pagefile in Windows, Swap Partition in Linux)
  5. Specialized Memory Types (ROM, NVRAM, MRAM, FeRAM, ReRAM, PRAM)
  6. Advanced Computing Memory (GPU, TPU, HBM, Persistent Memory)
  7. Cloud & Distributed Memory 
     - RAMDisk (Using RAM as disk storage)
     - Distributed Shared Memory (DSM, for cloud computing)
     - Object Storage Memory (AWS S3, Google Cloud Storage)
  8. Quantum Memory (Experimental)
     - Qubits-based Quantum Memory

  â€¢ MEMORY MANAGEMENT TECHNIQUES:
     1. Memory Allocation Techniques
        - Contiguous Allocation: Single Partition, Fixed Partitioning, Dynamic Partitioning.
        - Non-Contiguous Allocation: Paging, Segmentation, Segmented Paging. 
          Virtual Memory (relies on Paging, Segmentation, or both)
     2. Virtual Memory Management
        - Paging: Demand Paging, Pre-Paging.
        - Page Replacement Algorithms: FIFO, LRU, LFU, Optimal (Beladyâ€™s), Clock (Second-Chance), Random.
        - Thrashing Prevention: Working Set Model, Page Fault Frequency (PFF) Model.
     3. Memory Mapping & Addressing
        - Memory-Mapped I/O (MMIO), Direct Memory Access (DMA), Shared Memory (IPC - Inter Process Communication), 
          Memory Protection (Bounds Checking, Access Rights).
     4. Dynamic Memory Management
        - Allocation: Stack Allocation, Heap Allocation.
        - Garbage Collection: Reference Counting, Mark & Sweep, Copying GC, Generational GC, Concurrent GC.
     5. Multiprogramming Memory Management 
        - Fixed Partitioning, Dynamic Partitioning, Paging & Segmentation, 
        - Swapping (Process Swapping, Context Switching), Memory Compaction (Defragmentation).
     6. Security & Isolation
        - Memory Protection Units (MPU), ASLR (Address Space Layout Randomization),
          Kernel/User Space Separation, Process Isolation (Sandboxing, VMs, Containers).
     7. Distributed & Cloud Memory Management
        - Distributed Shared Memory (DSM), Memory Deduplication (Kernel Same-page Merging - KSM), 
          Remote Direct Memory Access (RDMA).


8ï¸âƒ£. What is Virtual Memory ? It's components and how it works ?

   - Virtual memory is a MEMORY MANAGEMENT TECHNIQUE used by OS 
     to give the appearance of a large, continuous block of memory to processes (while actually being non-contiguous),
     even if the physical memory (RAM) is limited.

   - Virtual memory enables multiprogramming by allowing processes to run without being fully loaded into RAM.
     Multiprogramming is when the OS keeps multiple processes in memory at the same time to improve CPU utilization.
   - Virtual memory enables processes to exceed physical memory by 
     storing inactive data on disk and loading only needed parts into RAM
   - Allows processes to use more memory than physically available (by using disk storage)
   - Provides protection so that processes cannot access each other's memory.
   - Enable efficient multitasking by swapping memory in and out as needed.
   
   â€¢ What Virtual Memory does in general?
     - Gives each process its own address space (process/memory isolation). 
       Then this address space is divided into segments (Stack, Heap, BSS, Data, Text).
       Each of these segments is further divided into fixed-size pages.
       Then those fixed-size pages are stored in PAGE TABLE. 
       Then PAGE TABLE is managed by OS (creates page tables, updates it, and handles faults) 
       and MMU(reads the page table and performs real-time address translation)

   â€¢ Virtual Memory Components (that make it work):
     1. Virtual Address Space â†’ The logical memory seen by a process (e.g., 0x0000A3B4).
     2. Physical Memory (RAM) â†’ The actual memory in the system.
     3. Page Table â†’ A mapping table that translates virtual addresses to physical addresses.
     4. Memory Management Unit (MMU) â†’ Hardware that performs address translation using the page table.
     5. Paging Mechanism â†’ Divides memory into fixed-size pages (virtual pages & physical frames).
     6. Page Fault Handling â†’ A mechanism that loads missing pages from disk when accessed.
     7. Swap Space (Page File) â†’ Disk storage used to hold inactive pages when RAM is full.
     8. TLB (Translation Lookaside Buffer) â†’ A cache that speeds up virtual-to-physical address translation.
     9. Demand Paging â†’ Loads pages into memory only when needed, reducing RAM usage.
     10. MMU (Memory Management Unit) - CPU part responsible for converting virtual addresses to physical addresses.

   â€¢ How Virtual Memory Works?
     - When a process starts, the OS creates its virtual address space (virtual memory space).
     - The OS allocates memory for different segments of process (code, stack, heap, data) on RAM (physical memory).
     - The process always sees virtual addresses, while the OS & MMU handle mapping to physical memory.
     - When a process accesses memory, the following steps happen:

       1. The process generates a virtual addresses (Virtual addresses are generated at runtime)

          Memory Region               | How Virtual Addresses Are Generated?       | Example Address
          ----------------------------|--------------------------------------------|------------------
          Code Segment (Text Section) | CPU fetches instruction                    | 0x400560
          Stack (Local Variables)     | Stack pointer decrements                   | 0x7ffdd3b4a2c8
          Heap (malloc)               | OS assigns a page from heap                | 0x563a9f4b2010
          Data Segment (Globals)      | OS assigns memory on process start         | 0x601040

       2. The MMU (Memory Management Unit) translates the virtual address to a physical address using the page table.
       3. If the page is in RAM, it retrieves the data.
       4. If the page is not in RAM (page fault), the OS loads it from disk (swap space or page file).

9ï¸âƒ£. What is a PAGE TABLE? And how it works and why it is needed ?
   - Page Table is a data structure used by the operating system to map virtual addresses to physical addresses in a paged memory system.
   - Page Table is stored in RAM and managed by the Memory Management Unit (MMU) of the CPU.
   - Page table is a crucial part of virtual memory management 
   - Each process has its own page table.
   - Each page table contains entries (Page Table Entries - PTEs).
   - Each entry maps a Virtual Page Number (VPN) to a Physical Frame Number (PFN) in RAM.
   ğŸ“Œ The actual pages (data) are stored in RAM or disk (swap space), not in the page table.

   Since modern systems use virtual memory, 
   processes use virtual addresses instead of direct physical addresses

   â€¢ Why the PAGE TABLE is needed ?
     - Translates Virtual Page Numbers (VPN) to Physical Frame Numbers (PFN)
     - Enables memory isolation for processes (process memory isolation - one process cannot access another process's memory).
       Each process has its own separate page table managed by OS and MMU.
     - Supports demand paging (loading pages into RAM only when needed)

   â€¢ How PAGE TABLE WORKS (per process) ? 
     1. When a process is created, the OS allocates a new page table for it
     2. The page table maps Virtual Page Numbers (VPN) to Physical Frame Numbers (PFN).
     3. When the process accesses memory, the MMU checks the page table to find the physical address
     4. When a process is terminated, its page table is deleted, and its memory is freed.

    â€¢ How Does the Virtual Address(VA) Relate to the Page Table?
      - The virtual address is used as an input to the page table lookup.
      - Virtual Addresses are NOT stored anywhere.
      - A Virtual Address is created dynamically when the CPU accesses memory. 
        Itâ€™s just a number used to index the page table and find the actual physical address.
      - Virtual Address (VA) = [Virtual Page Number (VPN) | Page Offset]
                             = [       20 bits (VPN)      | 12 bits (Offset) ]

        NOTE: VA scheme above is for a 32-bit Virtual Address, 4 KB Page Size

    â€¢ Virtual address structure:
         1. PAGE NUMBER (Virtual) -> Identifies which page the virtual address belongs to
            - Page Number is also virtual because it is part of the virtual address.
            - Virtual Page Number (VPN) maps to Physical Phrame Number (PFN) in the Page Table. (VPN <--> PFN)
            This mapping is managed by the OS and used by the 
            Memory Management Unit (MMU - part of CPU) for address translation.

         2. PAGE OFFSET -> Specifies the exact location withing that page (of the page in Page Table)
            - Part of part of both virtual address and physical adress
            - Different CPU architectures may have different offset sizes depending on page size.
            - Same in Virtual and Physical memory

         â€¢  PAGE SIZE is determined by the CPU architecture and the operating system
            - ARM (64-bit)	- Common Page Sizes: 4 KB, 16 KB, 64 KB
            - ARM (32-bit)	- Common Page Sizes: 4 KB, 64 KB
            - x86-64 (64-bit)	- Common Page Sizes: 4 KB, 2 MB, 1 GB
            - x86 (32-bit)	- Common Page Sizes: 4 KB, 4 MB
            - Terminal command: getconf PAGE_SIZE

         
      !!! Only the Page Number gets translated into a Physical Frame Number via the Page Table
            The Offset remains unchanged.

         â€¢ Example Virtual-to-Physical mapping: 

            Virtual Address  â†’  [Virtual Page Number] + [Offset]
                  â¬‡ (Translation using Page Table)
            Physical Address â†’  [Physical Frame Number] + [Offset]

         â€¢ Example with 32-bit Virtual Address: 
            â€¢ Page size = 4 KB â†’ Offset is 12 bits.
            â€¢ Virtual address is 32-bit â†’ Remaining 20 bits are Page Number.

            Virtual Address (32-bit)
            --------------------------------------
            | Virtual Page Number (20 bits) | Offset (12 bits) |
            --------------------------------------

            Physical Address (PA)
            --------------------------------------
            | Physical Frame Number (20 bits) | Page Offset (12 bits) |
            --------------------------------------


      - Example code:
         int x = 24;
         printf("%p", &x); // virtual address of x is 0x16d9a2f08

